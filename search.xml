<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[方法论-元学习践行三部曲之编程-笔记]]></title>
      <url>%2F2020%2F09%2F05%2F%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%85%83%E5%AD%A6%E4%B9%A0%E8%B7%B5%E8%A1%8C%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[给自己设计游戏规则和边界，不断地获得正反馈。 一、进入新手村STEP1:建立对学习内容的基本认知比如学习编程。 编程就是自动地解决问题： 观察一件事情输入了什么，导致输出了什么 思考事情可以重复被做的方法 不要期待错误的方法能够得到正确的结果 STEP2:拼出学习内容学习不是登山，而是拼图。因为对于一个全新的学习内容，人的大脑没有办法用未知解决未知。可以先不用左脑的逻辑分析模式，而是用右脑模式去感知所学内容，形成一个大致的外貌。抓全局，这样才不至于发生由入门到放弃的悲剧。心理学对拖延症的解释就是：害怕失败，追求完美。Xdite战胜拖延症的方法：骗骗自己，只是随便玩玩。 理论依据：认知心理学、“拼图理论” 学习要有成就感，要让自己停不下来。 比如学习编程，应该先快速把东西拼出来，拼一个大东西，然后公开给朋友，接受朋友的赞美，得到正向回馈。而不是苦逼的把一本书从头看到尾。 [练习与资源] 推荐书籍《创造力培训：像艺术家一样思考》 用右脑模式画画练习：拿出自己的照片，倒着画自画像 STEP3:抢在放弃之前建立正循环建立正循环： 模仿——小项目 –&gt; 大项目 –&gt; 发布 –&gt; 激励 “玩手游”三步：执行任务，获得新手技能——熟悉掌握——不断获得奖励，沉浸其中。 “学编程”三步：快速把东西拼出来 –&gt; 拼出更大的东西 –&gt; 公开并享受称赞。 理论依据：通过不断的正向反馈能过获得成就感 认知心理学理论：不断的重复训练可以形成肌肉记忆，把工作记忆存储到长期记忆中。 提出左右脑配合的肌肉快速入门法。通过先用右脑感知，模仿，熟悉基本框架，再放左脑出来理性分析。 批判了自学效率低的四个大坑： 必须有天赋 必须要看懂每一个步骤，才能往前进 学习必须要扎实，要从技术原理开始学起 学习当中禁止用一切捷径，比如说复制粘贴代码，模仿别人的程序。 初始加速度一定要大，不断地获得成就感；熟悉框架后需要复习时才适合用以上四个大坑。 [练习与资源] 用iPad 玩swift playground 儿童学习编程软件 scratch 二、晋级高级新手STEP1:获得高频小套路付费寻找要学习领域的专家级高手，获得一个“高频小套路”，即这个领域20个最常用的动作，或核心知识，形成对一个领域的框架 找出一本实做型的入门指南。最好三天内可以搞定，写完一个小项目。翻开书，直接跳到最后的项目，快速做3遍： 第一遍： 复制项目代码； 第二遍： 跟着打代码，熟悉基本工具，阅读错误信息，学会Debug； 第三遍， 分析打错的，为什么会错。体会输入什么，就会得到什么。把懂的，不懂的，都背下来。 还有独门秘籍：用markdown把自己特别傻逼犯错的地方记下来，把正确的解法也记下来，然后公开发表。同时，自己也背下来。 STEP2:加速全盘模仿学习新技能的时候初速度一定要快，最快的方法就是左右脑配合。“分散模式”和“专注模式”交替进行。不问理由的全盘模仿。 STEP3:大量重复练习大脑善于调出过去的记忆对事情进行判断，但大脑不能用未知理解未知，因为理解是记忆的相关连接。所以对于新知，大脑很难理解，因为大脑无法调出相关记忆。从这个角度来说，大脑对于新领域是不善于思考的。对策就是：利用高频小套路，全盘模仿，进行大量练习，形成肌肉（长期）记忆。 所以，人人可以通过高频小套路，快速成为高级新手或胜任者 XDite提到了德雷福斯模型，新手 –&gt; 高级新手 –&gt; 胜任者 –&gt; 精通者 –&gt; 专家。 其实市面上大于50%的都是高级新手。任何人只要有一份高频小套路的SOP，都快速成为高级新手甚至胜任者，可以入行得到一份职位。 专家都不是靠坚持得来的，而是上瘾和停不下来。要运用游戏化机制，行动 –&gt; 回馈 –&gt; 不确定的回馈，让自己上瘾。 这一点，我可以胜任，通宵打游戏，用虚拟人生复刻自己小时候的社区，连夜追韩剧，看小说，我，你都可以的。 什么是高频小套路？ 高频小套路，就是大牛抽取的最核心、最重要、最常出现那部分学习内容（按80/20法则，通常是20%）。 比如编程，就是最最常用的函数、模块，一个完整小项目的最核心最基础的部分。 比如跳舞，就是最常出现的舞步。 比如TOFEL词汇，就是核心词2140个。 关于英语的高频小套路，多读，多朗读，大声朗读，还有精度原版书和背诵金句。然而，有多少人严格要求自己天天朗读？有多少人坚持每天阅读一小时原版书？坚持每天背诵金句？ 关于写作的高频小套路，多读多读多读，增加输入质量；多写多写多写，高频率练习，磨炼输出技能。又多少人真的做到？ 反复练习要反复几次？ 起码三次：全栈营代码练习，官方答复是起码3次。注意起码。随着练习的次数增多，一次比一次熟练，一次比一次体会深。 每天练习： 写作练习，李笑来老师当年是每天写3000字，雷打不动。哪怕别的事耽搁了，很晚了，夜深了，没写也得写，必须写。既然决定了，就绝对不能妥协。 反复练习的总量，起码要多少？ 400小时。一般从新手到高级新手的程度，使用高频小套路练习，需要400小时。虽然相比吓人的10000小时，400小时不过1/25。但是，你只练3次，一次10小时，还差得远。 高频小套路是1，你的高频练习是后面的零。如过练习一次，1就是1，数量级太小，根本没用！练1次后面加一个0，越到后面，你的能力提升的越快。（当然，练到一定程度，会出现边际效应，你该练下一个高频小套路啦） 高频小套路不是内功，大牛无法直接转输给你。高频小套路是大牛写的武功秘籍，需要你反复的练习，不断的练习，刻意的练习，才能为你所用，才能让你的能力迅速增长，才能见自己、见天地、见众生（有幸的话） [练习与资源] （修改为自己设计的资源） 编程入门方法:选一本实做型教材，做三遍； Xdite 推荐:《Rails bridge :intro to rails》 如何有效的提取练习？ xdite 老师说：大多数人读书学习是：打开课本，画重点、抄笔记。然后复习时，重读这些重点以及笔记。(有没有中枪？)而真正有效的提取练习应该是：禁止打开课本重点与笔记, 拿一张全新的白纸, 默写: 回想之前划了哪些重点为什么要划这些重点然后，打开当初的课本重点，与【回想笔记】对照。【我的体验】一开始提取练习时，感觉非常不舒服，很想逃避。很想打开书偷看, 不愿默写。但当我硬着头皮，强行提取，发现：咦！以前记不住的，提取之后，都记住了，而且不易忘。 三、跨越到专家德雷福斯模型表达了专业技能的五个层级。 从低级到高级是：新手——高级新手——胜任者——精通者——专家 （在《程序员思维修炼》中有具体阐述）75%以上的从业者都处于新手和高级新手的层次。“一万小时理论”只适用于不断精进自己能力的练习，一年的经验重复十年是没有用的。那么如何从新手和高级新手跨越到人数稀少的专家行列呢？ A way:成瘾 高级新手以上的大牛的字典里是没有“坚持”二字的，他们只是上瘾了。成瘾的方法是：有明确的目标，时时得到正反馈，形成正循环。 将学习游戏化 将机械式行为游戏化，这样可以避免常规学习方式的无刺激感 游戏比日常习惯有更强力的刺激 游戏历程： 发现一个新游戏——用户开始玩——用户知道规则后，达成多个胜利状态——弃玩 模仿游戏的设计方法设计自己的学习模式 游戏是建立习惯的系统性公式：形成习惯回路——形成惯性行为——得到回报——直接相关人得到奖励 Behavior= Motive+Ability+Trigger 游戏让用户上瘾的方法是：奖励的大小、奖励出现的时间、奖励的内容是随机的 不要害怕上瘾 很多杰出的专家，身上都有的模式：各个都是瘾君子，很容易上瘾。大师是成瘾到停不下来的人。上瘾是高生产力、大进步的方式，保持容易成瘾的状态、迅速闯过高级新手这一关。 奖励自己 设计奖励 所谓兴趣，是行为得到奖励后的产物。帮助自己来实现自我。让学到的内容得到奖励的方法：讲给别人、教会别人、得到一个演出的机会，获得商业价值等。也就是实现自我价值。 降低行动门槛，不断自我实现。 人的行为可以被设计：Behavior= Motive+Ability+Trigger 不止游戏，类比好多商家营销、公司奖金、工资设计，创造上瘾的学习方式 参考资料: XDite 演讲 元学习实践（五）高频小套路是武功秘籍，反复练习才能为我所用——爱莉莎]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-Web-JSP-EL表达式]]></title>
      <url>%2F2016%2F09%2F05%2FJavaWeb%2FJava-Web-JSP-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 EL表达式1.1 什么是EL表达式 jsp中的 EL(express language) 表达式技术：它仅仅是表达式 。 EL表达式的功能：获取 4 个内置对象（域）中的数据，或自定义对象中的数据，或数组、集合容器中的数据。可以完成非常简单的运行。它不能完成循环、复杂的判断等功能。 EL表达式的书写格式：${ 表达式 } 1.2 EL表达式获取域对象中的数据格式1: ${xxxxScope.key}使用 EL 表达式从不同的域中取出数据，需要使用 EL 中的 4 个内置对象搞定: pageScope, requestScope, sessionScope, applicationScope 在 4 个 EL 内置对象 xxxxScope 取出保存的数据时，相当于使用pageContext.getAttribute(key,scope);取值 提示: scope 英 [skəʊp] 美 [skop] n. 作用域[计算机]; 范围；余地；视野 context 英 [&#39;kɒntekst] 美 [&#39;kɑntɛkst] n. 语境[计算机]; 环境；上下文；来龙去脉 格式2: ${key}如果不知道数据在哪个范围中，这时可以不用指定范围直接书写key值即可 ${key} 下面代码的底层对应的是 pageContext.findAttribute(name); getAttribute() 和 findAttribute() 区别 findAttribute 方法依次在 page, request, session（如果有效的话）和 application Scope（范围）查找以name为名的Attribute，找到就返回对象，都找不到返回null。 getAttribute 方法在 page scope 内查找与 name 相关的属性，找到返回就返回对象，找不到就返回 null。 两种的区别是，查找范围不同。 示例: 需求1: 通过 EL 表达式 从指定域中获取数据 (比较和 Java 代码的不同) 需求2: 通过 EL 表达式 从不确定域中获取数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;!-- JSP 有九大内置对象: page(Object), request(HttpServletRequest), session(HttpSession), application(ServletContext), pageContext(PageContext), response(HttpServletResponse), config(ServletConfig), exception(Throwable), out(JspWriter) --&gt; &lt;!-- 其中四大域对象: page(Object), request(HttpServletRequest), session(HttpSession), application(ServletContext) --&gt; &lt;% pageContext.setAttribute(&quot;city&quot;, &quot;北京1&quot;); pageContext.setAttribute(&quot;city&quot;, &quot;北京2&quot;, PageContext.REQUEST_SCOPE); pageContext.setAttribute(&quot;city&quot;, &quot;北京3&quot;, PageContext.SESSION_SCOPE); pageContext.setAttribute(&quot;city&quot;, &quot;北京4&quot;, PageContext.APPLICATION_SCOPE); // 如下注释部分记得测试, 看看结果 // pageContext.removeAttribute(&quot;city&quot;); // pageContext.removeAttribute(&quot;city&quot;, PageContext.REQUEST_SCOPE); // pageContext.removeAttribute(&quot;city&quot;, PageContext.PAGE_SCOPE); %&gt; &lt;h3&gt;需求1: 通过 EL 表达式 从指定域中获取数据 (比较和 Java 代码的不同)&lt;/h3&gt; &lt;h4&gt;Java 代码获取数据&lt;/h4&gt; page: &lt;%=pageContext.getAttribute(&quot;city&quot;) %&gt; &lt;br/&gt; request: &lt;%=pageContext.getAttribute(&quot;city&quot;, PageContext.REQUEST_SCOPE) %&gt; &lt;br/&gt; session: &lt;%=pageContext.getAttribute(&quot;city&quot;, PageContext.SESSION_SCOPE) %&gt; &lt;br/&gt; application: &lt;%=pageContext.getAttribute(&quot;city&quot;, PageContext.APPLICATION_SCOPE) %&gt; &lt;br/&gt; &lt;h4&gt;EL 表达式获取数据&lt;/h4&gt; page: $&#123;pageScope.city &#125; &lt;br/&gt; request: $&#123;requestScope.city &#125; &lt;br/&gt; session: $&#123;sessionScope.city &#125; &lt;br/&gt; application: $&#123;applicationScope.city &#125; &lt;br/&gt; &lt;h3&gt;需求2: 通过 EL 表达式从不确定域中获取数据&lt;/h3&gt; &lt;h4&gt;Java 代码获取数据&lt;/h4&gt; &lt;%-- &lt;%=pageContext.getAttribute(&quot;city&quot;) %&gt; --%&gt; &lt;%=pageContext.findAttribute(&quot;city&quot;) %&gt; &lt;h4&gt;EL 表达式获取数据&lt;/h4&gt; $&#123;city &#125; &lt;hr/&gt; &lt;h3&gt;提示: getAttribute 与 findAttribute 的区别&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; findAttribute 依次在page，request，session（如果有效的话）和application Scope（范围）查找以name为名的Attribute，找到就返回对象，都找不到返回null。&lt;/li&gt; &lt;li&gt; getAttribute 在page scope内查找与name相关的属性，找到返回就返回对象，找不到就返回null。 &lt;/li&gt; &lt;li&gt;两种的区别是，查找范围不同。&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 提示：通过上面的演示，发现 EL 表达式从四个域中取值，就是在代替使用 PageContext 中的 getAttribute 方法取值的麻烦，底层依然在使用 PageContext 中的 getAttribute 方法。 注意：使用 pageContext 的 getAttribute 方法或者 findAttribute 方法从 4 个范围中取出数据的时候，如果指定的 key 不存在会得到 null，而使用 EL 表达式取出的时候指定的 key 不存在，页面上什么都没有。 123Java代码获取值: &lt;%=pageContext.getAttribute(&quot;address&quot;,PageContext.PAGE_SCOPE) %&gt;&lt;hr/&gt;EL表达式: $&#123;pageScope.address&#125; 页面结果： 12Java 代码获取值: nullEL 表达式: 1.3 EL 表达式获取复杂数据这里说的复杂数据是指：数组，集合，自定义对象。 演示 EL 获取数组中的值1234567891011&lt;h2&gt;获取域中 数组的值&lt;/h2&gt;&lt;!-- 为了演示方便, 直接在 JSP 内使用 Java 代码! --&gt;&lt;% int[] arr = &#123;521, 1314, 2046&#125;; // out.println(arr); // 将数组保存到域对象中 pageContext.setAttribute(&quot;arr&quot;, arr);%&gt;数组: $&#123;pageScope.arr &#125; &lt;br/&gt;数组: $&#123;arr &#125; &lt;br/&gt;元素: $&#123;arr[0] &#125; $&#123;arr[1] &#125; $&#123;arr[2] &#125; &lt;br/&gt; 演示EL获取集合中的值123456789101112131415161718192021&lt;h2&gt;获取域中 list集合中的值&lt;/h2&gt;&lt;% List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Collections.addAll(list, &quot;Java&quot;, &quot;JavaScript&quot;, &quot;Python&quot;, &quot;PHP是世界上最好的语言!&quot;); pageContext.setAttribute(&quot;list&quot;, list);%&gt;集合: $&#123;list &#125; &lt;br/&gt;元素: $&#123;list[0] &#125; $&#123;list[1] &#125; $&#123;list[2] &#125; $&#123;list[3] &#125; &lt;br/&gt;元素: $&#123;list.get(0) &#125; $&#123;list.get(1) &#125; $&#123;list.get(2) &#125; $&#123;list.get(3) &#125; &lt;br/&gt;&lt;h2&gt;获取域中 Map 集合中的值&lt;/h2&gt;&lt;% Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;Java&quot;, 1); map.put(&quot;JavaScript&quot;, 2); map.put(&quot;Python&quot;, 3); pageContext.setAttribute(&quot;map&quot;, map);%&gt;集合: $&#123;map &#125; &lt;br/&gt;元素: Java=$&#123;map[&quot;Java&quot;] &#125; JavaScript=$&#123;map[&quot;JavaScript&quot;] &#125; Python=$&#123;map[&quot;Python&quot;] &#125; &lt;br/&gt;元素: Java=$&#123;map.Java &#125; JavaScript=$&#123;map.JavaScript &#125; Java=$&#123;map.Python &#125; &lt;br/&gt; 演示EL获取自定义对象属性值首先需要在项目中创建一个自定义的对象，这里创建 User 对象。并且针对 User 对象中的属性提供相应的 get 和 set 方法。 注意：在使用 EL 表达式取出数组、集合、自定义对象中的数据的时候，能够使用 . 的地方都可以使用中括号。特别是在 Map 集合或者自定义对象中 key 值或自定义对的属性名中包含多个字符的时候必须使用中括号搞定。 12345678910111213141516171819202122232425262728293031323334353637383940package com.songpeng.domain;public class User &#123; private int id; private String username; private String nickname; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; public String getAddress() &#123; return &quot;辽宁省辽阳市通明山 薛仁贵(收)&quot;; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, nickname=&quot; + nickname + &quot;]&quot;; &#125;&#125; 1234567891011121314151617181920&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;获取 域中自定义对象中的数据&lt;/h2&gt; &lt;jsp:useBean id=&quot;user&quot; class=&quot;com.songpeng.domain.User&quot; scope=&quot;page&quot;&gt;&lt;/jsp:useBean&gt; &lt;jsp:setProperty property=&quot;id&quot; name=&quot;user&quot; value=&quot;3&quot;/&gt; &lt;jsp:setProperty property=&quot;username&quot; name=&quot;user&quot; value=&quot;薛仁贵&quot;/&gt; &lt;jsp:setProperty property=&quot;nickname&quot; name=&quot;user&quot; value=&quot;仁贵&quot;/&gt; 自定义对象: $&#123;user &#125; &lt;br/&gt; 属性: $&#123;user.id &#125; $&#123;user.username &#125; $&#123;user.nickname &#125; &lt;br/&gt; 地址: $&#123;user.address &#125; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 注意：在 EL 表达式中，获取对象的属性的值的时候，其实不是在看这个对象所在的类是否有这个属性，只要这个对象所在的类中有 getXxxxx 方法，就可以使用 EL 表达式获取 Xxx 值。 演示 EL 获取 Map 值1234567891011121314&lt;h2&gt;演示 EL 获取 Map 值&lt;/h2&gt;&lt;% Map&lt;String, Integer&gt; map2 = new HashMap&lt;String, Integer&gt;(); map2.put(&quot;www.iamsongpeng.com&quot;, 1990); map2.put(&quot;songpeng&quot;, 95); map2.put(&quot;dapeng&quot;, 2); pageContext.setAttribute(&quot;map2&quot;, map2);%&gt;集合: $&#123;map2 &#125; &lt;br/&gt;元素: www.iamsongpeng.com=$&#123;map2[&quot;www.iamsongpeng.com&quot;] &#125; &lt;br/&gt;元素: www.iamsongpeng.com=$&#123;map2[&apos;www.iamsongpeng.com&apos;] &#125; &lt;br/&gt;元素: songpeng=$&#123;map2.songpeng &#125; &lt;br/&gt;元素: dapeng=$&#123;map2.dapeng &#125; &lt;br/&gt; 1.4 EL 表达式执行运算 使用 EL 进行简单的运算的时候，如果指定的范围中的 key 不存在，这时就不会去使用这个值计算，但是存在的依然会进行运算 12&lt;h2&gt;需求1: 将 a 和 b 保存到 page 域中, 使用 EL 表达式计算 a+b&lt;/h2&gt;&lt;h2&gt;需求2: 将 a 和 b 保存到 page 域中, 使用 EL 计算&lt;/h2&gt; 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;需求1: 将 a 和 b 保存到 page 域中, 使用 EL 表达式计算 a+b&lt;/h2&gt; &lt;% pageContext.setAttribute(&quot;a&quot;, 1); pageContext.setAttribute(&quot;b&quot;, 1); %&gt; a + b = $&#123;a + b &#125; &lt;br/&gt; &lt;h2&gt;需求2: 将 a 和 b 保存到 page 域中, 使用 EL 计算&lt;/h2&gt; a + b + c = $&#123;a + b + c &#125; &lt;br/&gt; 注: 上述 c 未定义! &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 12a + b = 2a + b + c = 2 可以使用 empty 验证某个容器或者变量是否为 null 格式: ${ empty 集合或变量等} 如果集合元素的个数为 0 或者 变量为 null 则返回 true, 否则返回 false 常用方式: EL 中三元运算符 ${empty 对象 ? 表达式1 : 表达式2 } ${not empty 对象 ? 表达式1 : 表达式2 } 12&lt;h2&gt;需求1: 使用 EL 表达式 判断集合是否为空&lt;/h2&gt;&lt;h2&gt;需求2: 使用 EL 表达式 判断用户是否存在&lt;/h2&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;%@page import=&quot;com.songpeng.domain.User&quot;%&gt;&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;&lt;%@page import=&quot;java.util.List&quot;%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;需求1: 使用 EL 表达式 判断集合是否为空&lt;/h2&gt; &lt;% List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;songpeng&quot;); pageContext.setAttribute(&quot;list&quot;, list); %&gt; empty list : $&#123;empty list &#125; &lt;br/&gt; not empty list : $&#123;not empty list &#125; &lt;br/&gt; &lt;h2&gt;需求2: 使用 EL 表达式 判断用户是否存在&lt;/h2&gt; &lt;% User user = new User(); user.setId(1); user.setUsername(&quot;柳岩&quot;); user.setNickname(&quot;大胸姐&quot;); // 存储数据到 域对象 pageContext.setAttribute(&quot;user&quot;, user, PageContext.SESSION_SCOPE); // 删除数据 // pageContext.removeAttribute(&quot;user&quot;, PageContext.SESSION_SCOPE); %&gt; $&#123;empty user ? &quot;匿名登录&quot; : user.nickname &#125; &lt;br/&gt; $&#123;not empty user ? user.nickname : &quot;匿名登录&quot; &#125; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 2 EL 的内置对象(11个)EL 表达式也有自己的内置对象可以直接在 EL 表达式中使用： 2.1 从不同的域中取值的四个内置对象：123456格式: $&#123;XXXScope.key&#125;pageScoperequestScopesessionScopeapplicationScope 准备工作: 123456&lt;% pageContext.setAttribute(&quot;address&quot;, &quot;北京1&quot;); // page pageContext.setAttribute(&quot;address&quot;, &quot;北京2&quot;, PageContext.REQUEST_SCOPE); // request pageContext.setAttribute(&quot;address&quot;, &quot;北京3&quot;, PageContext.SESSION_SCOPE); // session pageContext.setAttribute(&quot;address&quot;, &quot;北京4&quot;, PageContext.APPLICATION_SCOPE); // application(ServletContext)%&gt; 同上 ++1.2 EL表达式获取域对象中的数据++ 2.2 专门获取浏览器请求服务器时携带参数的 2 内置对象：param 获取用户提交的某个数据 可以理解成: request.getParameter(name) paramValues 获取某个key对应的多个value值 可以理解成: request.getParameterValues(name) 准备数据 WebContent/ELDemo/06-form.jsp: 12345678910111213141516171819202122&lt;body&gt; &lt;form action=&quot;/day18_my/08.jsp&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名: &lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好: &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;running&quot; /&gt; 跑步 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;bungee &quot; /&gt; 蹦极 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;golf&quot; /&gt; 高尔夫 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt; 123456&lt;body&gt; requestScope域对象是否为空: $&#123;empty requestScope &#125; &lt;br/&gt; 姓名: &lt;%=request.getParameter(&quot;username&quot;) %&gt; &lt;br/&gt; 姓名: $&#123;param.username &#125; &lt;br/&gt; 爱好: $&#123;paramValues.hobby[0] &#125; $&#123;paramValues.hobby[1] &#125; $&#123;paramValues.hobby[2] &#125; &lt;br/&gt;&lt;/body&gt; 2.3 专门获取浏览器请求服务器时请求头中数据的 2 个内置对象： header 获取请求头中的信息 headerValues 某个请求头中的多个value值 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Java 代码&lt;/h3&gt; user-agent: &lt;%=request.getHeader(&quot;user-agent&quot;) %&gt; &lt;/br&gt; cookie: &lt;%=request.getHeader(&quot;cookie&quot;) %&gt; &lt;/br&gt; &lt;h3&gt;EL 表达式&lt;/h3&gt; user-agent: $&#123;header[&quot;user-agent&quot;] &#125; &lt;br/&gt; cookie: $&#123;header.cookie &#125; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 2.4 cookie它获取到的一个cookie数组 获取cookie对象: ${cookie.cookie的名称}, 如 ${cookie.username} 获取cookie对象的名称: ${cookie.cookie的名称.name} 如: ${cookie.username.name} 获取cookie对象的值 : ${cookie.cookie的名称.value} 如: ${cookie.username.value} 需求: 在JSP页面向浏览器发送cookie, 在访问时获取cookie中的数据 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@page import=&quot;java.util.Date&quot;%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;需求: 在 JSP 页面向浏览器发送 cookie, 在访问时获取 cookie 中的数据&lt;/h2&gt; &lt;h3&gt;通过 Java 获取 cookie 中的数据&lt;/h3&gt; &lt;% String lastVisitTime = null; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie c : cookies) &#123; if (&quot;lastVisitTime&quot;.equals(c.getName())) &#123; lastVisitTime = c.getValue(); &#125; &#125; &#125; out.println(&quot;上次访问时间: &quot; + lastVisitTime); %&gt; &lt;h3&gt;通过EL获取cookie中的数据&lt;/h3&gt; cookie: $&#123;cookie.lastVisitTime &#125; &lt;br/&gt; cookie.name: $&#123;cookie.lastVisitTime.name &#125; &lt;br/&gt; cookie.value: $&#123;cookie.lastVisitTime.value &#125; &lt;!-- 创建cookie 保存上次访问时间 发送cookie --&gt; &lt;% Cookie cookie = new Cookie(&quot;lastVisitTime&quot;, new Date().toLocaleString()); cookie.setMaxAge(60 * 60 * 24 * 7 * 2); cookie.setPath(&quot;/&quot;); response.addCookie(cookie); %&gt;&lt;/body&gt;&lt;/html&gt; 注意: 再次访问登录页面, 用户名回显 2.5 其他对象pageContext 和 JSP 内置对象 pageContext 功能一致 initParam 获取的项目的全局配置参数，类似于 ServletContext 中的 getInitParameter(String name) 方法功能（它只能获取到 web.xml 配置的全局参数，每个 servlet 单独配置的无法使用 initParam 获取）。 12345678910111213141516171819202122232425&lt;%@page import=&quot;java.util.Date&quot;%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;获取项目的路径&lt;/h2&gt; &lt;h3&gt;Java&lt;/h3&gt; 方式一: request.getContextPath=&lt;%=request.getContextPath() %&gt; &lt;br/&gt; 方式二: context.getContextpath=&lt;%=application.getContextPath() %&gt; &lt;br/&gt; 方式三: config.context.getContextpath=&lt;%=config.getServletContext().getContextPath() %&gt; &lt;br/&gt; 方式四: pageContext.request.getContextPath= &lt;% HttpServletRequest req = (HttpServletRequest)pageContext.getRequest(); out.println(req.getContextPath()); %&gt; &lt;h3&gt;EL&lt;/h3&gt; 方式一: pageContext.request.contextPath=$&#123;pageContext.request.contextPath &#125; &lt;br/&gt; 方式二: pageContext.servletContext.contextPath=$&#123;pageContext.servletContext.contextPath &#125; &lt;/body&gt;&lt;/html&gt; 2.6 jsp的内置对象和EL的内置对象区分 JSP 页面中的Java代码中可以直接使用的对象称为JSP的内置对象。&lt;% 可以直接使用的对象 %&gt; EL表达式中11个内置对象，在EL表达式中也可以直接去使用这些对象${ EL的内置对象.key值或者其他的信息 } Github上有完整示例代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-Web-JSP-taglib指令]]></title>
      <url>%2F2016%2F09%2F05%2FJavaWeb%2FJava-Web-JSP-taglib%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Demo图示 需求 需求: 输出 1~10 分析 因为taglib指令主要是在页面上引入其他已经定义好的标签或者函数（其实就是在引入Java程序或者理解成类）。所以需要导包, 将如下两个.jar复制到/WebContent/WEB-INF/lib jstl.jar standard.jar 概念和方法在 JSP 页面上是可以书写 Java 代码，也可以书写 html 代码，一般公司中页面是由美工维护，而我们负责后台开发。因此不建议在JSP页面上嵌入过多的Java代码。这时就需要把Java代码从页面中剔除。将页面上需要书写的所有标签都封装到对应的单独的 Java 程序中，然后在页面中使用 taglib 指令引入。引入的这些 Java 程序可以通过对应的标签体现。其实这些标签的背后还是 Java 代码。仅仅只是 JSP 页面上没有了 Java 代码而已。 taglib 指令：主要是在页面上引入其他已经定义好的标签或者函数（其实就是在引入Java程序或者理解成类）。 例如：这里引入一个使用频率非常高的标签作为演示 在taglib指令中的属性： uri：是当前标签对应的Java代码封装之后绑定的名称空间（给java代码专门的命名） prefix：它是当前在页面上可以使用的标签的前缀。 需求: 向浏览器打印1~10 代码Github上有完整代码 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;taglib指令&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;需求: 输出 1~10&lt;/h2&gt; &lt;h3&gt;实现: 方式一&lt;/h3&gt; &lt;p&gt;脚本片段内使用for循环, 使用脚本表达式进行输出&lt;/p&gt; &lt;% for(int i=1; i&lt;=10; i++) &#123; %&gt; &lt;div style=&quot;background-color: aquamarine&quot;&gt;&lt;%= i %&gt;&lt;/div&gt; &lt;% &#125; %&gt; &lt;h3&gt;实现: 方式二&lt;/h3&gt; &lt;p&gt;taglib指令实现&lt;/p&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot; var=&quot;i&quot;&gt; &lt;div style=&quot;background-color: darkcyan&quot;&gt;$&#123;pageScope.i &#125;&lt;/div&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; JSP文件123&lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; step=&quot;1&quot; var=&quot;i&quot;&gt; $&#123;pageScope.i &#125;&lt;/c:forEach&gt; 翻译后的.java文件1234out.write(&quot;\t&quot;);if (_jspx_meth_c_005fforEach_005f0(_jspx_page_context))return;out.write(&quot;\r\n&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML-发现一个逆天的问题(文档中没有说明的问题)]]></title>
      <url>%2F2016%2F09%2F05%2FHTML%2FHTML-%E5%8F%91%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%86%E5%A4%A9%E7%9A%84%E9%97%AE%E9%A2%98(%E6%96%87%E6%A1%A3%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%AF%B4%E6%98%8E%E7%9A%84%E9%97%AE%E9%A2%98)%2F</url>
      <content type="text"><![CDATA[Demo图示 代码Github上有完整代码 12&lt;option selected=false&gt;大连市&lt;/option&gt; &lt;!-- 这样也可以 --&gt;&lt;!--&lt;option selected=null&gt;大连市&lt;/option&gt;--&gt; &lt;!-- 这样也可以 --&gt; 12&lt;!--篮球：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot; checked=false&gt;--&gt; &lt;!-- 这样也可以 --&gt;篮球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;basketball&quot; checked=null&gt; &lt;!-- 这样也可以 --&gt; 一个哥们儿无意间发现的，是不是要说些什么！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-Web-JSP-脚本元素]]></title>
      <url>%2F2016%2F09%2F05%2FJavaWeb%2FJava-Web-JSP-%E8%84%9A%E6%9C%AC%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[Demo图示 需求 输出数字1~10, 奇数为颜色为darkcyan, 偶数颜色为aquamarine 分析 方式一: 脚本片段和脚本表达式结合使用; 方式二: 脚本片段和脚本表达式结合使用; 方式三: 脚本片段, 脚本表达式和脚本声明结合使用; 相关语法 脚本声明格式 123&lt;%! 书写对应的Java代码%&gt; 脚本声明: 成员变量, 成员方法, 内部类 脚本表达式格式 12&lt;%=表达式 %&gt;表达式内容: 常量 or 变量 or 结果的输出 注意：脚本表达式不能书写java代码的结束标记分号。 脚本片段 脚本片段格式：首先说明，这种格式使用的非常少，而且书写的时候，一定要留心！ 1234&lt;% Java代码 %&gt;html代码&lt;% Java代码%&gt;... 代码Github上有完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;p&gt;需求: 输出数字1~10,奇数为颜色为darkcyan,偶数颜色为aquamarine&lt;/p&gt; &lt;p&gt;实现: 方式一&lt;/p&gt; &lt;% for (int i = 1; i &lt;= 10; i++) &#123; if (i % 2 == 0) &#123; %&gt; &lt;div style=&quot;background-color: aquamarine&quot;&gt;&lt;%=i%&gt;&lt;/div&gt; &lt;% &#125; else &#123; %&gt; &lt;div style=&quot;background-color: darkcyan&quot;&gt;&lt;%=i%&gt;&lt;/div&gt; &lt;% &#125; &#125; %&gt; &lt;p&gt;实现: 方式二&lt;/p&gt; &lt;% for (int i = 1; i &lt;= 10; i++) &#123; %&gt; &lt;div style=&quot;background-color: &lt;%=i % 2 == 0 ? &quot;aquamarine&quot; : &quot;darkcyan&quot;%&gt;&quot;&gt;&lt;%=i%&gt;&lt;/div&gt; &lt;% &#125; %&gt; &lt;p&gt;实现: 方式三&lt;/p&gt; &lt;%! public String getColor(int i) &#123; return i % 2 == 0 ? &quot;aquamarine&quot; : &quot;darkcyan&quot;; &#125; %&gt; &lt;% for (int i = 1; i &lt;= 10; i++) &#123; %&gt; &lt;div style=&quot;background-color:&lt;%=getColor(i)%&gt;&quot;&gt;&lt;%=i%&gt;&lt;/div&gt; &lt;% &#125; %&gt;&lt;/body&gt;]]></content>
    </entry>

    
  
  
</search>
